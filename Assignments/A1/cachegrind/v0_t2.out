--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./driver inputs/input_1000000.txt 2
Data file:        cachegrind.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr  ILmr  Dr          D1mr    DLmr   Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
2,007,470,886 3,459 3,102 764,194,329 794,396 11,105 271,258,467 780,778 197,156  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr    DLmr  Dw         D1mw    DLmw    file:function
--------------------------------------------------------------------------------
648,531,275   26   24 219,078,053     122   119 68,966,895  62,500 62,500  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<unsigned int>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, unsigned int&) const
598,199,616   15   14 252,938,851 199,871   205 72,238,200 254,444    341  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:SequentialSort(unsigned int*, unsigned int)
159,895,717  668  587  47,029,816   2,018    79  9,348,499     695     16  ???:???
131,871,034    2    2  60,482,510     128     0 16,896,502       0      0  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:binary_search(unsigned int*, unsigned int, unsigned int)
 98,540,417   26   26  30,179,759      50     5 27,143,048   1,478    524  ???:GOMP_task
 70,000,000    4    4  34,000,000  62,529     0 15,000,000  62,504 61,302  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int) [clone ._omp_fn.3]
 64,975,402   10    9  30,031,888 322,699     2 27,000,161 332,995  7,815  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
 62,000,598    8    7  25,000,168      11    10  7,000,134       0      0  ???:std::istream::sentry::sentry(std::istream&, bool)
 58,010,560   41   41  25,002,803 125,990 1,473 15,001,634  62,556 62,504  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int)
 47,000,047    4    4  17,000,017       2     0  9,000,009       0      0  ???:std::istream& std::istream::_M_extract<unsigned int>(unsigned int&)
 23,000,166   17   17   6,000,030       8     4  3,000,044       2      2  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp:main
 20,999,996    4    4   8,999,995  62,501     0          5       0      0  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp:check_sorted(unsigned int*, int)
  6,001,266    2    2   2,000,518      11     6          0       0      0  ???:std::locale::id::_M_id() const
  4,000,000    1    1   2,000,000       0     0          0       0      0  ???:std::basic_ios<char, std::char_traits<char> >::operator bool() const
  4,000,000    0    0   3,000,000       0     0          0       0      0  ???:omp_get_thread_num

--------------------------------------------------------------------------------
-- Auto-annotated source: /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr   DLmr Dw        D1mw DLmw 

         .    .    .         .      .    .         .    .    .  #include "psort.h"
         .    .    .         .      .    .         .    .    .  #include <chrono>
         .    .    .         .      .    .         .    .    .  #include <fstream>
         .    .    .         .      .    .         .    .    .  #include <iostream>
         .    .    .         .      .    .         .    .    .  #include <omp.h>
         .    .    .         .      .    .         .    .    .  #include <stdint.h>
         .    .    .         .      .    .         .    .    .  
         6    1    1         0      0    0         3    0    0  void check_sorted(uint32_t *data, int n) {
 5,999,999    1    1 2,999,999      0    0         1    0    0    for (int i = 0; i < n - 1; i++) {
14,999,985    1    1 5,999,994 62,501    0         0    0    0      if (data[i] > data[i + 1]) {
         .    .    .         .      .    .         .    .    .        std::cout << data[i] << ' ' << data[i + 1] << ' ' << i << '\n';
         .    .    .         .      .    .         .    .    .        std::cout << "Data is not sorted.\n";
         .    .    .         .      .    .         .    .    .        return;
         .    .    .         .      .    .         .    .    .      }
         .    .    .         .      .    .         .    .    .    }
         .    .    .         .      .    .         .    .    .  
         3    1    1         0      0    0         1    0    0    std::cout << "Data is sorted.\n";
         1    0    0         0      0    0         0    0    0    return;
         2    0    0         2      0    0         0    0    0  }
         .    .    .         .      .    .         .    .    .  
        11    1    1         1      0    0         6    0    0  void SortData(uint32_t *data, uint32_t n, int p, int n_threads) {
        50    3    1        20      0    0        16    0    0  #pragma omp parallel num_threads(n_threads)
         .    .    .         .      .    .         .    .    .    {
         .    .    .         .      .    .         .    .    .  #pragma omp single
         6    0    0         3      0    0         1    0    0      ParallelSort(data, n, p);
         .    .    .         .      .    .         .    .    .    }
         6    1    1         4      1    1         0    0    0  }
         .    .    .         .      .    .         .    .    .  
        10    2    2         1      0    0         5    0    0  int main(int argc, char *argv[]) {
         2    0    0         1      0    0         0    0    0    if (argc < 3) {
         .    .    .         .      .    .         .    .    .      std::cout << "Insufficient Arguments\n"; // <datafile> <n_threads>
         .    .    .         .      .    .         .    .    .      return 0;
         .    .    .         .      .    .         .    .    .    }
         .    .    .         .      .    .         .    .    .  
        12    1    1         2      1    0         2    0    0    std::fstream fs(argv[1], std::fstream::in);
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Reading data
         1    0    0         0      0    0         1    0    0    uint32_t n, d = 0;
         6    1    1         2      0    0         2    0    0    int p, n_threads = atoi(argv[2]);
        10    0    0         0      0    0         2    0    0    fs >> n >> p;
        10    1    1         1      0    0         2    0    0    uint32_t *data = new uint32_t[n];
         .    .    .         .      .    .         .    .    .  
        13    1    1         2      1    0         3    0    0    std::cout << "n_threads = " << n_threads << std::endl;
        21    2    2         3      0    0         5    0    0    std::cout << "N = " << n << " p = " << p << std::endl;
         .    .    .         .      .    .         .    .    .  
19,999,999    1    1 4,000,000      0    0 3,000,000    0    0    while (fs >> data[d++])
 3,000,000    0    0 2,000,000      0    0         0    0    0      if (d == n)
         1    0    0         0      0    0         0    0    0        break;
         .    .    .         .      .    .         .    .    .  
         3    0    0         0      0    0         1    0    0    fs.close();
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Sorting
         2    1    1         0      0    0         2    0    0    auto begin = std::chrono::high_resolution_clock::now();
         6    0    0         4      0    0         1    0    0    SortData(data, n, p, n_threads);
         2    1    1         0      0    0         2    1    1    auto end = std::chrono::high_resolution_clock::now();
         .    .    .         .      .    .         .    .    .    double duration =
         1    0    0         0      0    0         0    0    0        (1e-6 *
        10    1    1         0      0    0         4    0    0         (std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin))
         6    1    1         1      1    1         2    1    1             .count());
         .    .    .         .      .    .         .    .    .  
         6    0    0         2      0    0         1    0    0    check_sorted(data, n);
        12    1    1         1      1    0         3    0    0    std::cout << "Time taken for sorting " << n << " elements with " << p
        20    1    1         3      2    1         5    0    0              << " buckets = " << duration << "ms" << std::endl;
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Clean-up
         5    1    1         2      0    0         1    0    0    delete[] data;
         .    .    .         .      .    .         .    .    .  
         1    0    0         0      0    0         0    0    0    return 0;
        28    4    4        11      2    2         5    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr Dw         D1mw    DLmw   

          .    .    .          .       .    .          .       .      .  #include "psort.h"
          .    .    .          .       .    .          .       .      .  #include <cstdint>
          .    .    .          .       .    .          .       .      .  #include <iostream>
          .    .    .          .       .    .          .       .      .  #include <omp.h>
          .    .    .          .       .    .          .       .      .  #include <string.h>
          .    .    .          .       .    .          .       .      .  #include <string>
          .    .    .          .       .    .          .       .      .  
 28,044,226    1    0  2,003,159     338    0 18,028,431   8,903    249  void SequentialSort(uint32_t *data, uint32_t n) {
  6,009,518    0    0  2,003,159       0    0          0       0      0    if (n <= 1)
          .    .    .          .       .    .          .       .      .      return;
  7,010,913    1    1  2,003,118       1    0  2,003,118       0      0    uint32_t nl = n / 2, nr = (n + 1) / 2;
 86,151,016    6    6  4,009,624   6,591  205  4,006,236       3      0    uint32_t left[nl], right[nr];
  7,010,913    0    0  3,004,677      42    0  1,001,559   3,109     92    memcpy(left, data, nl * sizeof(uint32_t));
 10,015,590    1    1  4,006,236     157    0  1,001,559       0      0    memcpy(right, data + nl, nr * sizeof(uint32_t));
  5,007,795    0    0  2,003,118     170    0  1,001,559       0      0    SequentialSort(left, nl);
  5,007,795    0    0  2,003,118     400    0  1,001,559       0      0    SequentialSort(right, nr);
  3,004,677    1    1          0       0    0  3,004,677     294      0    uint32_t l = 0, r = 0, i = 0;
 91,540,221    0    0 56,502,830      69    0          0       0      0    while (l < nl && r < nr) {
107,167,848    0    0 80,375,886 191,181    0          0       0      0      if (left[l] <= right[r])
 99,150,075    0    0 33,050,025      59    0 19,830,015 121,265      0        data[i++] = left[l++];
          .    .    .          .       .    .          .       .      .      else
 95,003,664    2    2 33,929,880      51    0 20,357,928 120,568      0        data[i++] = right[r++];
          .    .    .          .       .    .          .       .      .    }
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (l < nl)
  6,868,410    1    1  2,747,364       1    0    457,894     158      0      memcpy(data + i, left + l, (n - i) * sizeof(uint32_t));
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (r < nr)
 13,162,852    0    0  3,261,990       0    0    543,665     144      0      memcpy(data + i, right + r, (n - i) * sizeof(uint32_t));
 22,034,749    2    2 18,028,431     811    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
  6,000,000    0    0          0       0    0  4,000,000       0      0  uint32_t binary_search(uint32_t *data, uint32_t p, uint32_t val) {
  3,000,000    0    0  1,000,000       0    0  2,000,000       0      0    uint32_t l = 0, r = p;
 21,802,516    0    0 12,896,502       0    0          0       0      0    while (l < r) {
 27,241,255    1    1 10,896,502       0    0  5,448,251       0      0      uint32_t mid = (l + r) >> 1;
 54,482,510    0    0 27,241,255     128    0          0       0      0      if (val <= data[(mid + 1) * p])
  8,971,464    0    0  2,990,488       0    0  2,990,488       0      0        r = mid;
          .    .    .          .       .    .          .       .      .      else
  7,373,289    0    0  2,457,763       0    0  2,457,763       0      0        l = mid + 1;
          .    .    .          .       .    .          .       .      .    }
  1,000,000    1    1  1,000,000       0    0          0       0      0    return r;
  2,000,000    0    0  2,000,000       0    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
          .    .    .          .       .    .          .       .      .  void print_arr(uint32_t *data, uint32_t n) {
          .    .    .          .       .    .          .       .      .    for (uint32_t j = 0; j < n; j++)
          .    .    .          .       .    .          .       .      .      std::cout << data[j] << ' ';
          .    .    .          .       .    .          .       .      .    std::cout << '\n';
          .    .    .          .       .    .          .       .      .  }
          .    .    .          .       .    .          .       .      .  
         15    2    2          1       0    0         10       0      0  void ParallelSort(uint32_t *data, uint32_t n, int p) {
          8    1    1          3       0    0          0       0      0    if (n / p < p) {
          .    .    .          .       .    .          .       .      .      SequentialSort(data, n);
          .    .    .          .       .    .          .       .      .      return;
          .    .    .          .       .    .          .       .      .    }
          .    .    .          .       .    .          .       .      .  
         66    5    5          8       1    0          4       0      0    uint32_t r[p * p + 1], sz = n / p, offset = (n % p) * (sz + 1);
          .    .    .          .       .    .          .       .      .  
          8    0    0          3       0    0          1       0      0    for (uint32_t j = 0; j < n % p; j++) {
          .    .    .          .       .    .          .       .      .  #pragma omp task shared(p, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
          .    .    .          .       .    .          .       .      .        uint32_t off1 = p * j, off2 = j * (sz + 1);
          .    .    .          .       .    .          .       .      .        for (uint32_t idx = 0; idx < p; idx++)
          .    .    .          .       .    .          .       .      .          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
        208    2    2        124       0    0          1       0      0    for (uint32_t j = n % p; j < p; j++) {
      2,440    4    4      1,040       0    0        840       2      2  #pragma omp task shared(p, offset, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
        560    1    1        280       0    0         80       0      0        uint32_t off1 = p * j, off2 = offset + (j - n % p) * sz;
      8,160    0    0      4,880       0    0         40       0      0        for (uint32_t idx = 0; idx < p; idx++)
     22,400    1    1     11,200     140    0      1,600      85      8          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          7    0    0          2       0    0          1       0      0    SequentialSort(r, p * p);
          5    1    1          2       0    0          1       0      0    r[p * p] = UINT32_MAX;
          .    .    .          .       .    .          .       .      .  
      5,014   10   10        985     973  973         17       1      0    uint32_t num_t = omp_get_num_threads(), b_size_t[p + 1][num_t], b_id[n];
        209    0    0        125       0    0          1       0      0    for (uint32_t j = 0; j <= p; j++) {
      1,804    2    2        656       0    0        574       2      2  #pragma omp task shared(b_size_t, num_t)
        451    1    1        123       0    0         41       0      0      memset(b_size_t[j], 0, (num_t) * sizeof(uint32_t));
          .    .    .          .       .    .          .       .      .    }
          1    1    1          0       0    0          1       0      0  #pragma omp taskwait
  5,000,004    0    0  3,000,002       4    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
 64,000,000    4    4 27,000,000       8    0 22,000,000       8      0  #pragma omp task shared(p, r, data, b_id, b_size_t)
          .    .    .          .       .    .          .       .      .      {
 13,000,000    1    1  7,000,000  62,505    0  2,000,000  62,502 61,302        b_id[j] = binary_search(r, p, data[j]);
 19,000,000    1    1  6,000,000      18    0  2,000,000       0      0        b_size_t[b_id[j] + 1][omp_get_thread_num()]++;
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
         45    4    4          2       1    0          6       3      0    uint32_t b_size[p + 1];
        209    0    0        125       0    0          1       1      0    for (uint32_t j = 0; j <= p; j++) {
        123    0    0         82       0    0         41       0      0      b_size[j] = 0;
      2,009    4    4        779       0    0        656       0      0  #pragma omp task shared(b_size, b_size_t, num_t)
        574    0    0        328       0    0         41       0      0      for (uint32_t t = 0; t < num_t; t++)
      1,230    1    1        738       0    0         82       0      0        b_size[j] += b_size_t[j][t];
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
        199    0    0        119       0    0          1       0      0    for (uint32_t j = 1; j < p; j++)
        468    1    1        312       0    0         39       0      0      b_size[j] += b_size[j - 1];
          .    .    .          .       .    .          .       .      .  
          8    1    1          1       0    0          2       0      0    uint32_t *b = new uint32_t[n];
  5,000,005    0    0  3,000,002       0    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
          .    .    .          .       .    .          .       .      .      // #pragma omp task shared(data, b_id, b_size, b)
          .    .    .          .       .    .          .       .      .      {
  4,000,000    1    1  3,000,000  62,500  288  1,000,000       0      0        uint32_t id = b_id[j], idx;
          .    .    .          .       .    .          .       .      .        // #pragma omp atomic capture
  8,000,000    0    0  5,000,000       0    0  2,000,000       0      0        idx = b_size[id]++;
 10,000,000    1    1  5,000,000  62,501  210  1,000,000  62,538 62,500        b[idx] = data[j];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          .    .    .          .       .    .          .       .      .    // #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
          7    1    1          3       0    0          1       0      0    memcpy(data, b, n * sizeof(uint32_t));
          5    0    0          2       1    0          1       0      0    delete[] b;
          1    0    0          1       1    0          0       0      0    sz *= 2;
        204    0    0        122       3    0          1       0      0    for (uint32_t j = 0; j < p; j++) {
      2,040    3    3        800      80    0        680       3      0  #pragma omp task shared(b_size, data, sz, p)
          .    .    .          .       .    .          .       .      .      {
        592    2    2        277      41    0         40       0      0        uint32_t nj = (j == 0 ? b_size[j] : b_size[j] - b_size[j - 1]),
        200    0    0        160       0    0         40       0      0                 i = b_size[j] - nj;
        120    0    0         80       0    0          0       0      0        if (nj < sz)
        360    1    1        120       0    0         40       2      0          SequentialSort(data + i, nj);
          .    .    .          .       .    .          .       .      .        else if (nj != 0)
          .    .    .          .       .    .          .       .      .          ParallelSort(data + i, nj, p);
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          5    0    0          1       1    0          2       0      0  #pragma omp taskwait
         32    3    3         15       3    2          5       0      0  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr    DLmr  Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
902,120,705  106  103 387,444,923 451,290 1,683 122,139,675 379,593 124,157  events annotated

