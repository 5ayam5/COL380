--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./driver input_1000000.txt 1
Data file:        cachegrind.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr  ILmr  Dr          D1mr    DLmr   Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
1,936,548,561 3,185 2,882 753,290,794 792,140 10,676 270,381,949 777,194 192,888  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr    DLmr  Dw         D1mw    DLmw    file:function
--------------------------------------------------------------------------------
648,531,275   26   24 219,078,053     122   119 68,966,895  62,500 62,500  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<unsigned int>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, unsigned int&) const
598,199,616   15   14 252,938,851 199,385   123 72,238,200 252,856    230  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:SequentialSort(unsigned int*, unsigned int)
131,871,034    2    2  60,482,510      12     0 16,896,502       0      0  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:binary_search(unsigned int*, unsigned int, unsigned int)
 98,034,717   26   26  30,011,443      12     6 27,009,368     417    283  ???:GOMP_task
 92,065,056  588  517  37,025,061   1,073    65  9,009,230     140     17  ???:???
 71,000,000    3    3  34,000,000  62,506     0 15,000,000  62,499 61,301  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int) [clone ._omp_fn.3]
 64,909,615    9    9  30,015,664 322,509     2 26,989,741 333,040  4,114  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
 62,000,598    8    7  25,000,168      12    10  7,000,134       0      0  ???:std::istream::sentry::sentry(std::istream&, bool)
 58,010,561   41   40  25,002,803 125,970 1,218 15,001,635  62,548 62,502  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int)
 47,000,047    4    4  17,000,017       2     0  9,000,009       0      0  ???:std::istream& std::istream::_M_extract<unsigned int>(unsigned int&)
 23,000,166   15   15   6,000,030       7     1  3,000,044       1      0  ???:main
 20,999,996    3    3   8,999,995  62,502     0          5       0      0  ???:check_sorted(unsigned int*, int)
  6,001,266    2    2   2,000,518      11     6          0       0      0  ???:std::locale::id::_M_id() const
  4,000,000    1    1   2,000,000       0     0          0       0      0  ???:std::basic_ios<char, std::char_traits<char> >::operator bool() const
  4,000,000    0    0   3,000,000       0     0          0       0      0  ???:omp_get_thread_num
  2,000,002    1    1           0       0     0          0       0      0  ???:std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::do_get(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, unsigned int&) const
  2,000,002    1    1           0       0     0          0       0      0  ???:std::istream::operator>>(unsigned int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr Dw         D1mw    DLmw   

          .    .    .          .       .    .          .       .      .  #include "psort.h"
          .    .    .          .       .    .          .       .      .  #include <cstdint>
          .    .    .          .       .    .          .       .      .  #include <iostream>
          .    .    .          .       .    .          .       .      .  #include <omp.h>
          .    .    .          .       .    .          .       .      .  #include <string.h>
          .    .    .          .       .    .          .       .      .  #include <string>
          .    .    .          .       .    .          .       .      .  
 28,044,226    1    0  2,003,159     316    0 18,028,431   8,874    169  void SequentialSort(uint32_t *data, uint32_t n) {
  6,009,518    0    0  2,003,159       0    0          0       0      0    if (n <= 1)
          .    .    .          .       .    .          .       .      .      return;
  7,010,913    1    1  2,003,118       0    0  2,003,118       0      0    uint32_t nl = n / 2, nr = (n + 1) / 2;
 86,151,016    6    6  4,009,624   6,737  123  4,006,236       1      0    uint32_t left[nl], right[nr];
  7,010,913    0    0  3,004,677      42    0  1,001,559   3,010     61    memcpy(left, data, nl * sizeof(uint32_t));
 10,015,590    1    1  4,006,236     142    0  1,001,559       0      0    memcpy(right, data + nl, nr * sizeof(uint32_t));
  5,007,795    0    0  2,003,118     196    0  1,001,559       0      0    SequentialSort(left, nl);
  5,007,795    0    0  2,003,118     360    0  1,001,559       0      0    SequentialSort(right, nr);
  3,004,677    1    1          0       0    0  3,004,677     268      0    uint32_t l = 0, r = 0, i = 0;
 91,540,221    0    0 56,502,830     104    0          0       0      0    while (l < nl && r < nr) {
107,167,848    0    0 80,375,886 190,658    0          0       0      0      if (left[l] <= right[r])
 99,150,075    0    0 33,050,025      33    0 19,830,015 119,935      0        data[i++] = left[l++];
          .    .    .          .       .    .          .       .      .      else
 95,003,664    2    2 33,929,880      17    0 20,357,928 120,472      0        data[i++] = right[r++];
          .    .    .          .       .    .          .       .      .    }
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (l < nl)
  6,868,410    1    1  2,747,364       0    0    457,894     153      0      memcpy(data + i, left + l, (n - i) * sizeof(uint32_t));
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (r < nr)
 13,162,852    0    0  3,261,990       0    0    543,665     143      0      memcpy(data + i, right + r, (n - i) * sizeof(uint32_t));
 22,034,749    2    2 18,028,431     780    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
  6,000,000    0    0          0       0    0  4,000,000       0      0  uint32_t binary_search(uint32_t *data, uint32_t p, uint32_t val) {
  3,000,000    0    0  1,000,000       0    0  2,000,000       0      0    uint32_t l = 0, r = p;
 21,802,516    0    0 12,896,502       0    0          0       0      0    while (l < r) {
 27,241,255    1    1 10,896,502       0    0  5,448,251       0      0      uint32_t mid = (l + r) >> 1;
 54,482,510    0    0 27,241,255      12    0          0       0      0      if (val <= data[(mid + 1) * p])
  8,971,464    0    0  2,990,488       0    0  2,990,488       0      0        r = mid;
          .    .    .          .       .    .          .       .      .      else
  7,373,289    0    0  2,457,763       0    0  2,457,763       0      0        l = mid + 1;
          .    .    .          .       .    .          .       .      .    }
  1,000,000    1    1  1,000,000       0    0          0       0      0    return r;
  2,000,000    0    0  2,000,000       0    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
          .    .    .          .       .    .          .       .      .  void print_arr(uint32_t *data, uint32_t n) {
          .    .    .          .       .    .          .       .      .    for (uint32_t j = 0; j < n; j++)
          .    .    .          .       .    .          .       .      .      std::cout << data[j] << ' ';
          .    .    .          .       .    .          .       .      .    std::cout << '\n';
          .    .    .          .       .    .          .       .      .  }
          .    .    .          .       .    .          .       .      .  
         15    2    2          1       0    0         10       0      0  void ParallelSort(uint32_t *data, uint32_t n, int p) {
          8    1    1          3       0    0          0       0      0    if (n / p < p) {
          .    .    .          .       .    .          .       .      .      SequentialSort(data, n);
          .    .    .          .       .    .          .       .      .      return;
          .    .    .          .       .    .          .       .      .    }
          1    1    1          0       0    0          1       0      0    const uint32_t PADDING = 1;
          .    .    .          .       .    .          .       .      .  
         66    4    4          8       1    0          4       0      0    uint32_t r[p * p + 1], sz = n / p, offset = (n % p) * (sz + 1);
          .    .    .          .       .    .          .       .      .  
          8    0    0          3       0    0          1       0      0    for (uint32_t j = 0; j < n % p; j++) {
          .    .    .          .       .    .          .       .      .  #pragma omp task shared(p, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
          .    .    .          .       .    .          .       .      .        uint32_t off1 = p * j, off2 = j * (sz + 1);
          .    .    .          .       .    .          .       .      .        for (uint32_t idx = 0; idx < p; idx++)
          .    .    .          .       .    .          .       .      .          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
        208    2    2        124       0    0          1       0      0    for (uint32_t j = n % p; j < p; j++) {
      2,440    4    4      1,040       0    0        840       1      1  #pragma omp task shared(p, offset, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
        560    1    1        280       0    0         80       0      0        uint32_t off1 = p * j, off2 = offset + (j - n % p) * sz;
      8,160    0    0      4,880       0    0         40       0      0        for (uint32_t idx = 0; idx < p; idx++)
     22,400    1    1     11,200     140    0      1,600      83      7          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          7    0    0          2       0    0          1       0      0    SequentialSort(r, p * p);
          5    1    1          2       0    0          1       0      0    r[p * p] = UINT32_MAX;
          .    .    .          .       .    .          .       .      .  
         91    6    6          7       0    0         11       1      0    uint32_t num_t = omp_get_num_threads(), b_size_t[p + 1][num_t * PADDING],
      4,923    4    4        978     973  973          6       2      0             b_id[n];
        209    0    0        125       0    0          1       0      0    for (uint32_t j = 0; j <= p; j++) {
      1,804    4    4        656       0    0        574       1      1  #pragma omp task shared(b_size_t, num_t)
        451    1    1        123       0    0         41       0      0      memset(b_size_t[j], 0, (num_t * PADDING) * sizeof(uint32_t));
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
  5,000,004    0    0  3,000,002       0    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
 64,000,000    3    3 27,000,000       4    0 22,000,000       1      0  #pragma omp task shared(p, r, data, b_id, b_size_t)
          .    .    .          .       .    .          .       .      .      {
 13,000,000    1    1  7,000,000  62,502    0  2,000,000  62,499 61,301        b_id[j] = binary_search(r, p, data[j]);
 20,000,000    1    1  6,000,000       0    0  2,000,000       0      0        b_size_t[b_id[j] + 1][omp_get_thread_num() * PADDING]++;
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
         45    4    4          2       0    0          6       1      0    uint32_t b_size[p + 1];
        209    0    0        125       0    0          1       0      0    for (uint32_t j = 0; j <= p; j++) {
        123    0    0         82       0    0         41       0      0      b_size[j] = 0;
      2,009    4    4        779       0    0        656       0      0  #pragma omp task shared(b_size, b_size_t, num_t)
        369    0    0        205       0    0         41       0      0      for (uint32_t t = 0; t < num_t; t++)
        615    1    1        369       0    0         41       0      0        b_size[j] += b_size_t[j][t * PADDING];
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
        199    0    0        119       0    0          1       0      0    for (uint32_t j = 1; j < p; j++)
        468    1    1        312       0    0         39       0      0      b_size[j] += b_size[j - 1];
          .    .    .          .       .    .          .       .      .  
          8    1    1          1       0    0          2       0      0    uint32_t *b = new uint32_t[n];
  5,000,005    0    0  3,000,002       0    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
          .    .    .          .       .    .          .       .      .      // #pragma omp task shared(data, b_id, b_size, b)
          .    .    .          .       .    .          .       .      .      {
  4,000,000    1    1  3,000,000  62,495  143  1,000,000       0      0        uint32_t id = b_id[j], idx;
          .    .    .          .       .    .          .       .      .        // #pragma omp atomic capture
  8,000,000    0    0  5,000,000       0    0  2,000,000       0      0        idx = b_size[id]++;
 10,000,000    1    1  5,000,000  62,496  102  1,000,000  62,540 62,500        b[idx] = data[j];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          .    .    .          .       .    .          .       .      .    // #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
          7    1    1          3       0    0          1       0      0    memcpy(data, b, n * sizeof(uint32_t));
          5    0    0          2       1    0          1       0      0    delete[] b;
          1    0    0          1       1    0          0       0      0    sz *= 2;
        204    1    1        122       0    0          1       0      0    for (uint32_t j = 0; j < p; j++) {
      2,040    2    2        800      42    0        680       2      0  #pragma omp task shared(b_size, data, sz, p)
          .    .    .          .       .    .          .       .      .      {
        592    3    3        277      42    0         40       0      0        uint32_t nj = (j == 0 ? b_size[j] : b_size[j] - b_size[j - 1]),
        200    0    0        160       0    0         40       0      0                 i = b_size[j] - nj;
        120    0    0         80       0    0          0       0      0        if (nj < sz)
        360    0    0        120       0    0         40       0      0          SequentialSort(data + i, nj);
          .    .    .          .       .    .          .       .      .        else if (nj != 0)
          .    .    .          .       .    .          .       .      .          ParallelSort(data + i, nj, p);
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          5    0    0          1       1    0          2       0      0  #pragma omp taskwait
         32    5    3         15       3    0          5       0      0  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr    DLmr  Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
859,119,630   79   76 372,444,372 388,098 1,341 119,139,558 377,987 124,040  events annotated

