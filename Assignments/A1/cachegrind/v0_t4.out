--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         12582912 B, 64 B, 24-way associative
Command:          ./driver input_1000000.txt 4
Data file:        cachegrind.out
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr  ILmr  Dr            D1mr    DLmr   Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
4,058,695,826 3,473 3,115 1,167,309,147 795,700 10,757 395,375,620 782,393 204,493  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr    DLmr  Dw         D1mw    DLmw    file:function
--------------------------------------------------------------------------------
1,745,237,169  677  597 328,048,836   1,591    82 68,008,228     347     27  ???:???
  648,531,275   26   24 219,078,053     122   119 68,966,895  62,500 62,500  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<unsigned int>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, unsigned int&) const
  598,199,616   15   14 252,938,851 200,787   339 72,238,200 257,009    446  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:SequentialSort(unsigned int*, unsigned int)
  185,029,878   22   22  59,009,558      59     4 50,008,077     808    248  ???:GOMP_task
  136,025,415   74   44  23,004,235      56     5 24,004,445     274     97  /build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c:_int_malloc
  131,871,034    2    2  60,482,510       0     0 16,896,502       4      0  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:binary_search(unsigned int*, unsigned int, unsigned int)
  127,019,254   43   22  39,005,577     316     2 12,002,621       8      0  /build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c:_int_free
   76,905,171   10    9  33,014,342 324,159     2 28,988,485 333,198 15,226  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
   74,012,482   18   10  20,003,371      51     2  4,000,692       0      0  /build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c:malloc
   71,000,000    3    3  34,000,000  62,501     0 15,000,000  62,500 61,307  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int) [clone ._omp_fn.3]
   62,000,598    8    7  25,000,168      12    10  7,000,134       0      0  ???:std::istream::sentry::sentry(std::istream&, bool)
   58,010,561   41   41  25,002,803 125,989   976 15,001,635  62,555 62,507  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp:ParallelSort(unsigned int*, unsigned int, int)
   47,000,047    4    4  17,000,017       2     0  9,000,009       0      0  ???:std::istream& std::istream::_M_extract<unsigned int>(unsigned int&)
   24,004,035   10    6   6,001,011     322     0         10       0      0  /build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c:free
   23,000,166   16   16   6,000,030       7     4  3,000,044       1      1  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp:main
   20,999,996    4    4   8,999,995  62,502     0          5       0      0  /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp:check_sorted(unsigned int*, int)
    8,999,082    1    1   2,999,694       1     0    999,898       0      0  /build/glibc-eX1tMB/glibc-2.31/malloc/arena.c:_int_free
    6,001,266    2    2   2,000,518      11     6          0       0      0  ???:std::locale::id::_M_id() const

--------------------------------------------------------------------------------
-- Auto-annotated source: /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/psort.cpp
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr Dw         D1mw    DLmw   

          .    .    .          .       .    .          .       .      .  #include "psort.h"
          .    .    .          .       .    .          .       .      .  #include <cstdint>
          .    .    .          .       .    .          .       .      .  #include <iostream>
          .    .    .          .       .    .          .       .      .  #include <omp.h>
          .    .    .          .       .    .          .       .      .  #include <string.h>
          .    .    .          .       .    .          .       .      .  #include <string>
          .    .    .          .       .    .          .       .      .  
 28,044,226    1    0  2,003,159     343    0 18,028,431   9,015    327  void SequentialSort(uint32_t *data, uint32_t n) {
  6,009,518    0    0  2,003,159       0    0          0       0      0    if (n <= 1)
          .    .    .          .       .    .          .       .      .      return;
  7,010,913    1    1  2,003,118       0    0  2,003,118       0      0    uint32_t nl = n / 2, nr = (n + 1) / 2;
 86,151,016    6    6  4,009,624   6,703  339  4,006,236       2      0    uint32_t left[nl], right[nr];
  7,010,913    0    0  3,004,677      42    0  1,001,559   3,082    119    memcpy(left, data, nl * sizeof(uint32_t));
 10,015,590    1    1  4,006,236     156    0  1,001,559       1      0    memcpy(right, data + nl, nr * sizeof(uint32_t));
  5,007,795    0    0  2,003,118     180    0  1,001,559       1      0    SequentialSort(left, nl);
  5,007,795    0    0  2,003,118     461    0  1,001,559       1      0    SequentialSort(right, nr);
  3,004,677    1    1          0       0    0  3,004,677     326      0    uint32_t l = 0, r = 0, i = 0;
 91,540,221    0    0 56,502,830      95    0          0       0      0    while (l < nl && r < nr) {
107,167,848    0    0 80,375,886 191,823    0          0       0      0      if (left[l] <= right[r])
 99,150,075    0    0 33,050,025      57    0 19,830,015 122,497      0        data[i++] = left[l++];
          .    .    .          .       .    .          .       .      .      else
 95,003,664    2    2 33,929,880      43    0 20,357,928 121,775      0        data[i++] = right[r++];
          .    .    .          .       .    .          .       .      .    }
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (l < nl)
  6,868,410    1    1  2,747,364       0    0    457,894     158      0      memcpy(data + i, left + l, (n - i) * sizeof(uint32_t));
  3,004,677    0    0  2,003,118       0    0          0       0      0    if (r < nr)
 13,162,852    0    0  3,261,990       0    0    543,665     151      0      memcpy(data + i, right + r, (n - i) * sizeof(uint32_t));
 22,034,749    2    2 18,028,431     884    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
  6,000,000    0    0          0       0    0  4,000,000       4      0  uint32_t binary_search(uint32_t *data, uint32_t p, uint32_t val) {
  3,000,000    0    0  1,000,000       0    0  2,000,000       0      0    uint32_t l = 0, r = p;
 21,802,516    0    0 12,896,502       0    0          0       0      0    while (l < r) {
 27,241,255    1    1 10,896,502       0    0  5,448,251       0      0      uint32_t mid = (l + r) >> 1;
 54,482,510    0    0 27,241,255       0    0          0       0      0      if (val <= data[(mid + 1) * p])
  8,971,464    0    0  2,990,488       0    0  2,990,488       0      0        r = mid;
          .    .    .          .       .    .          .       .      .      else
  7,373,289    0    0  2,457,763       0    0  2,457,763       0      0        l = mid + 1;
          .    .    .          .       .    .          .       .      .    }
  1,000,000    1    1  1,000,000       0    0          0       0      0    return r;
  2,000,000    0    0  2,000,000       0    0          0       0      0  }
          .    .    .          .       .    .          .       .      .  
          .    .    .          .       .    .          .       .      .  void print_arr(uint32_t *data, uint32_t n) {
          .    .    .          .       .    .          .       .      .    for (uint32_t j = 0; j < n; j++)
          .    .    .          .       .    .          .       .      .      std::cout << data[j] << ' ';
          .    .    .          .       .    .          .       .      .    std::cout << '\n';
          .    .    .          .       .    .          .       .      .  }
          .    .    .          .       .    .          .       .      .  
         15    2    2          1       0    0         10       1      1  void ParallelSort(uint32_t *data, uint32_t n, int p) {
          8    1    1          3       0    0          0       0      0    if (n / p < p) {
          .    .    .          .       .    .          .       .      .      SequentialSort(data, n);
          .    .    .          .       .    .          .       .      .      return;
          .    .    .          .       .    .          .       .      .    }
          1    1    1          0       0    0          1       0      0    const uint32_t PADDING = 1;
          .    .    .          .       .    .          .       .      .  
         66    4    4          8       1    1          4       0      0    uint32_t r[p * p + 1], sz = n / p, offset = (n % p) * (sz + 1);
          .    .    .          .       .    .          .       .      .  
          8    0    0          3       0    0          1       0      0    for (uint32_t j = 0; j < n % p; j++) {
          .    .    .          .       .    .          .       .      .  #pragma omp task shared(p, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
          .    .    .          .       .    .          .       .      .        uint32_t off1 = p * j, off2 = j * (sz + 1);
          .    .    .          .       .    .          .       .      .        for (uint32_t idx = 0; idx < p; idx++)
          .    .    .          .       .    .          .       .      .          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
        208    2    2        124       0    0          1       0      0    for (uint32_t j = n % p; j < p; j++) {
      2,440    4    4      1,040       0    0        840       4      4  #pragma omp task shared(p, offset, sz, r, data)
          .    .    .          .       .    .          .       .      .      {
        560    1    1        280       0    0         80       0      0        uint32_t off1 = p * j, off2 = offset + (j - n % p) * sz;
      8,160    0    0      4,880       0    0         40       0      0        for (uint32_t idx = 0; idx < p; idx++)
     22,400    1    1     11,200     140    0      1,600      94     83          r[off1 + idx] = data[off2 + idx];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          7    0    0          2       0    0          1       0      0    SequentialSort(r, p * p);
          5    1    1          2       0    0          1       0      0    r[p * p] = UINT32_MAX;
          .    .    .          .       .    .          .       .      .  
         91    6    6          7       0    0         11       1      0    uint32_t num_t = omp_get_num_threads(), b_size_t[p + 1][num_t * PADDING],
      4,923    4    4        978     973  973          6       0      0             b_id[n];
        209    0    0        125       0    0          1       0      0    for (uint32_t j = 0; j <= p; j++) {
      1,804    4    4        656       0    0        574       2      2  #pragma omp task shared(b_size_t, num_t)
        451    1    1        123       0    0         41       0      0      memset(b_size_t[j], 0, (num_t * PADDING) * sizeof(uint32_t));
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
  5,000,004    0    0  3,000,002       0    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
 64,000,000    3    3 27,000,000       0    0 22,000,000       3      0  #pragma omp task shared(p, r, data, b_id, b_size_t)
          .    .    .          .       .    .          .       .      .      {
 13,000,000    1    1  7,000,000  62,501    0  2,000,000  62,497 61,307        b_id[j] = binary_search(r, p, data[j]);
 20,000,000    1    1  6,000,000       0    0  2,000,000       0      0        b_size_t[b_id[j] + 1][omp_get_thread_num() * PADDING]++;
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
         45    4    4          2       0    0          6       1      0    uint32_t b_size[p + 1];
        209    0    0        125       0    0          1       0      0    for (uint32_t j = 0; j <= p; j++) {
        123    0    0         82       0    0         41       1      1      b_size[j] = 0;
      2,009    4    4        779       0    0        656       1      1  #pragma omp task shared(b_size, b_size_t, num_t)
        984    0    0        574       0    0         41       0      0      for (uint32_t t = 0; t < num_t; t++)
      2,460    1    1      1,476       0    0        164       0      0        b_size[j] += b_size_t[j][t * PADDING];
          .    .    .          .       .    .          .       .      .    }
          1    0    0          0       0    0          1       0      0  #pragma omp taskwait
        199    0    0        119       0    0          1       0      0    for (uint32_t j = 1; j < p; j++)
        468    1    1        312       0    0         39       0      0      b_size[j] += b_size[j - 1];
          .    .    .          .       .    .          .       .      .  
          8    1    1          1       0    0          2       0      0    uint32_t *b = new uint32_t[n];
  5,000,005    0    0  3,000,002       0    0          1       0      0    for (uint32_t j = 0; j < n; j++) {
          .    .    .          .       .    .          .       .      .      // #pragma omp task shared(data, b_id, b_size, b)
          .    .    .          .       .    .          .       .      .      {
  4,000,000    1    1  3,000,000  62,500    1  1,000,000       0      0        uint32_t id = b_id[j], idx;
          .    .    .          .       .    .          .       .      .        // #pragma omp atomic capture
  8,000,000    0    0  5,000,000       0    0  2,000,000       0      0        idx = b_size[id]++;
 10,000,000    1    1  5,000,000  62,501    1  1,000,000  62,537 62,500        b[idx] = data[j];
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          .    .    .          .       .    .          .       .      .    // #pragma omp taskwait
          .    .    .          .       .    .          .       .      .  
          7    1    1          3       0    0          1       0      0    memcpy(data, b, n * sizeof(uint32_t));
          5    0    0          2       1    0          1       0      0    delete[] b;
          1    0    0          1       1    0          0       0      0    sz *= 2;
        204    1    1        122       9    0          1       0      0    for (uint32_t j = 0; j < p; j++) {
      2,040    2    2        800      78    0        680      10      1  #pragma omp task shared(b_size, data, sz, p)
          .    .    .          .       .    .          .       .      .      {
        592    2    2        277      40    0         40       0      0        uint32_t nj = (j == 0 ? b_size[j] : b_size[j] - b_size[j - 1]),
        200    0    0        160       0    0         40       0      0                 i = b_size[j] - nj;
        120    0    0         80       0    0          0       0      0        if (nj < sz)
        360    1    1        120       0    0         40       3      0          SequentialSort(data + i, nj);
          .    .    .          .       .    .          .       .      .        else if (nj != 0)
          .    .    .          .       .    .          .       .      .          ParallelSort(data + i, nj, p);
          .    .    .          .       .    .          .       .      .      }
          .    .    .          .       .    .          .       .      .    }
          5    0    0          1       1    0          2       0      0  #pragma omp taskwait
         32    5    4         15       3    0          5       0      0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /mnt/2C3E11673E112AFA/Users/Sayam Sethi/Documents/IITD Material/Sem 6/COL380/Assignments/A1/driver.cpp
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr   DLmr Dw        D1mw DLmw 

         .    .    .         .      .    .         .    .    .  #include "psort.h"
         .    .    .         .      .    .         .    .    .  #include <chrono>
         .    .    .         .      .    .         .    .    .  #include <fstream>
         .    .    .         .      .    .         .    .    .  #include <iostream>
         .    .    .         .      .    .         .    .    .  #include <omp.h>
         .    .    .         .      .    .         .    .    .  #include <stdint.h>
         .    .    .         .      .    .         .    .    .  
         6    1    1         0      0    0         3    0    0  void check_sorted(uint32_t *data, int n) {
 5,999,999    1    1 2,999,999      0    0         1    0    0    for (int i = 0; i < n - 1; i++) {
14,999,985    1    1 5,999,994 62,501    0         0    0    0      if (data[i] > data[i + 1]) {
         .    .    .         .      .    .         .    .    .        std::cout << data[i] << ' ' << data[i + 1] << ' ' << i << '\n';
         .    .    .         .      .    .         .    .    .        std::cout << "Data is not sorted.\n";
         .    .    .         .      .    .         .    .    .        return;
         .    .    .         .      .    .         .    .    .      }
         .    .    .         .      .    .         .    .    .    }
         .    .    .         .      .    .         .    .    .  
         3    1    1         0      0    0         1    0    0    std::cout << "Data is sorted.\n";
         1    0    0         0      0    0         0    0    0    return;
         2    0    0         2      1    0         0    0    0  }
         .    .    .         .      .    .         .    .    .  
        11    1    1         1      0    0         6    0    0  void SortData(uint32_t *data, uint32_t n, int p, int n_threads) {
        88    3    1        36      0    0        28    0    0  #pragma omp parallel num_threads(n_threads)
         .    .    .         .      .    .         .    .    .    {
         .    .    .         .      .    .         .    .    .  #pragma omp single
         6    0    0         3      0    0         1    0    0      ParallelSort(data, n, p);
         .    .    .         .      .    .         .    .    .    }
         6    1    1         4      2    2         0    0    0  }
         .    .    .         .      .    .         .    .    .  
        10    1    1         1      0    0         5    0    0  int main(int argc, char *argv[]) {
         2    0    0         1      0    0         0    0    0    if (argc < 3) {
         .    .    .         .      .    .         .    .    .      std::cout << "Insufficient Arguments\n"; // <datafile> <n_threads>
         .    .    .         .      .    .         .    .    .      return 0;
         .    .    .         .      .    .         .    .    .    }
         .    .    .         .      .    .         .    .    .  
        12    1    1         2      1    0         2    0    0    std::fstream fs(argv[1], std::fstream::in);
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Reading data
         1    0    0         0      0    0         1    0    0    uint32_t n, d = 0;
         6    1    1         2      0    0         2    0    0    int p, n_threads = atoi(argv[2]);
        10    1    1         0      0    0         2    0    0    fs >> n >> p;
        10    0    0         1      0    0         2    0    0    uint32_t *data = new uint32_t[n];
         .    .    .         .      .    .         .    .    .  
        13    1    1         2      1    0         3    0    0    std::cout << "n_threads = " << n_threads << std::endl;
        21    2    2         3      0    0         5    0    0    std::cout << "N = " << n << " p = " << p << std::endl;
         .    .    .         .      .    .         .    .    .  
19,999,999    1    1 4,000,000      0    0 3,000,000    0    0    while (fs >> data[d++])
 3,000,000    0    0 2,000,000      0    0         0    0    0      if (d == n)
         1    0    0         0      0    0         0    0    0        break;
         .    .    .         .      .    .         .    .    .  
         3    1    1         0      0    0         1    0    0    fs.close();
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Sorting
         2    0    0         0      0    0         2    0    0    auto begin = std::chrono::high_resolution_clock::now();
         6    0    0         4      0    0         1    0    0    SortData(data, n, p, n_threads);
         2    1    1         0      0    0         2    0    0    auto end = std::chrono::high_resolution_clock::now();
         .    .    .         .      .    .         .    .    .    double duration =
         1    1    1         0      0    0         0    0    0        (1e-6 *
        10    1    1         0      0    0         4    1    1         (std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin))
         6    0    0         1      1    1         2    0    0             .count());
         .    .    .         .      .    .         .    .    .  
         6    0    0         2      0    0         1    0    0    check_sorted(data, n);
        12    1    1         1      0    0         3    0    0    std::cout << "Time taken for sorting " << n << " elements with " << p
        20    2    2         3      2    1         5    0    0              << " buckets = " << duration << "ms" << std::endl;
         .    .    .         .      .    .         .    .    .  
         .    .    .         .      .    .         .    .    .    // Clean-up
         5    0    0         2      0    0         1    0    0    delete[] data;
         .    .    .         .      .    .         .    .    .  
         1    0    0         0      0    0         0    0    0    return 0;
        28    4    4        11      2    2         5    0    0  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-eX1tMB/glibc-2.31/malloc/arena.c
  /build/glibc-eX1tMB/glibc-2.31/malloc/malloc.c
  /build/glibc-eX1tMB/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr    DLmr  Dw          D1mw    DLmw    
--------------------------------------------------------------------------------
903,122,384  107  103 387,445,923 452,047 1,321 122,139,770 382,169 124,347  events annotated

